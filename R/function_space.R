## This file is part of fdaPDE, a C++ library for physics-informed
## spatial and functional data analysis.

## This program is free software: you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, either version 3 of the License, or
## (at your option) any later version.

## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.

## You should have received a copy of the GNU General Public License
## along with this program.  If not, see <http://www.gnu.org/licenses/>.

.CppFunctionSpace <- setRefClass(
    Class = "CppFunctionSpace",
    fields = c(
        cpp_handler = "ANY"  ## pointer to cpp backend
    ),
    methods = c(
        ## evaluates the basis system on the given set of locations
        eval = function(type = c("pointwise", "areal"), locations) {
            type <- match.arg(type)
            return(cpp_handler$eval(match(type, c("pointwise", "areal")) - 1, locations))
        }
    )
)

.FunctionSpaceCtr <- setRefClass(
    Class = "FunctionSpaceObject",
    fields = c(
        mesh = "ANY",         ## ???
        function_space = "CppFunctionSpace",  ## cpp backend
        fe_order = "numeric"  ## this is specific for fem, must be generalized
    ),
    methods = c(
        get_basis = function() { return(function_space) },
        ## integrates a function expressed as basis expansion with respect to this basis system over the
        ## whole domain of definition
        integrate = function(func) {
            if (!(is.function(func) || is.vector(func))) stop("invalid argument, should be either a function or a vector")
            ## required dof coordinates...
            c <- func
            if (is.function(func)) { ## recover fem expansion
                c <- func(mesh$cpp_handler$nodes())
            }
            return(function_space$cpp_handler$integrate(c))
        }
    )
)

# constructor
setGeneric("FunctionSpace", function(mesh, fe_order) standardGeneric("FunctionSpace"))

#' Create FunctionSpace object
#'
#' @param mesh A mesh object created by \code{Mesh}:
#' @param fe_order Either '1' or '2'. It specifies the finite element order.
#' @return An S4 object representing a Function Space.
#' @export 
#' @examples
#' library(femR)
#' data("unit_square")
#' mesh <- Mesh(unit_square)
#' Vh <- FunctionSpace(mesh)
setMethod("FunctionSpace",
    signature = c(mesh = "ANY", fe_order = "numeric"),
    function(mesh, fe_order) {
        .FunctionSpaceCtr(
            function_space = .CppFunctionSpace(cpp_handler = new(
                eval(
                    parse(text = paste("cpp_lagrange_basis_", mesh$domain_type, "_fe", as.character(fe_order), sep = ""))
                ),
                mesh$cpp_handler, 0
            )),
            mesh = mesh,
            fe_order = fe_order
        )
    }
)

setMethod("FunctionSpace",
    signature = c(mesh = "ANY", fe_order = "missing"),
    function(mesh) {
        FunctionSpace(mesh, 1L)
    }
)

## finite element function
.FunctionCtr <- setRefClass(
    Class = "FunctionObject",
    fields = c(
        FunctionSpace = "ANY",
        coeff = "matrix"
    ),
    methods = list(
        eval_at = function(X) {
            M <- dim(FunctionSpace$mesh$nodes())[2]
            if (is.vector(X)) {
                pde$eval(FunctionSpace$mesh$data, coeff, matrix(X, nrow = 1, ncol = M))
            } else {
                if (dim(X)[2] != M) {
                    stop(paste("matrix of evaluation points should be an N x", M, "matrix"))
                }
                pde$eval(FunctionSpace$mesh$data, coeff, as.matrix(X))
            }
        }
    )
)

## constructor

#' Create Function object
#'
#' @param FunctionSpace a FunctionSpace object created by \code{FunctionSpace}:
#' @return An S4 object representing a Function belonging to the FunctionSpace passed as parameter.
#' @export 
#' @examples
#' library(femR)
#' data("unit_square")
#' mesh <- Mesh(unit_square)
#' Vh <- FunctionSpace(mesh)
#' f <- Function(Vh)
Function <- function(FunctionSpace) {
    coeff <- matrix(ncol = 1, nrow = 0)
    .FunctionCtr(coeff = coeff, FunctionSpace = FunctionSpace)
}

## FunctionObject plot overload

#' Plot a Function object
#'
#' @param x A \code{FunctionObject} generated by \code{Function}
#' @param ... Arguments representing graphical options to be passed to \link[plotly]{plot_ly}.
#' @return A \link[plotly] object
#' @export
setMethod("plot", signature = c(x = "FunctionObject"), function(x, ...) {
    times <- x$FunctionSpace$mesh$times
    is_parabolic <- FALSE
    if (length(times) != 0) is_parabolic <- TRUE
    if (!is_parabolic) {
        plot_data <- data.frame(
            X = x$FunctionSpace$mesh$nodes()[, 1],
            Y = x$FunctionSpace$mesh$nodes()[, 2],
            coeff = x$coeff[1:nrow(x$FunctionSpace$mesh$nodes())]
        )
        I <- x$FunctionSpace$mesh$elements()[, 1]
        J <- x$FunctionSpace$mesh$elements()[, 2]
        K <- x$FunctionSpace$mesh$elements()[, 3]
        fig <- plot_ly(plot_data,
            x = ~X, y = ~Y, z = ~coeff,
            i = I, j = J, k = K,
            intensity = ~coeff, color = ~coeff, type = "mesh3d",
            colorbar = list(title = ""), ...
        ) %>%
            layout(
                scene = list(
                    aspectmode = "data",
                    xaxis = list(
                        title = "", showgrid = F, zeroline = F, showticklabels = F
                    ),
                    yaxis = list(
                        title = "", showgrid = F, zeroline = F, showticklabels = F
                    ),
                    zaxis = list(
                        title = "", showgrid = F, zeroline = F, showticklabels = F
                    )
                ),
                camera = list(
                    eye = list(x = 1.25, y = -1.25, z = 1.25)
                )
            ) %>%
            colorbar(len = 1, title = "")
    } else {
        plot_data <- data.frame(
            X = rep(x$FunctionSpace$mesh$nodes()[, 1], times = length(times)),
            Y = rep(x$FunctionSpace$mesh$nodes()[, 2], times = length(times)),
            coeff = as.vector(x$coeff[1:nrow(x$FunctionSpace$mesh$nodes()), ]),
            times = rep(times, each = nrow(x$FunctionSpace$mesh$nodes()))
        )
        limits <- c(min(x$coeff), max(x$coeff))
        I <- x$FunctionSpace$mesh$elements()[, 1]
        J <- x$FunctionSpace$mesh$elements()[, 2]
        K <- x$FunctionSpace$mesh$elements()[, 3]
        fig <- plot_ly(plot_data,
            x = ~X, y = ~Y, z = ~coeff, frame = ~times,
            i = I, j = J, k = K, cmin = limits[1], cmax = limits[2],
            intensity = ~coeff, color = ~coeff, type = "mesh3d",
            colorbar = list(title = ""), ...
        ) %>%
            layout(
                scene = list(
                    aspectmode = "data",
                    xaxis = list(
                        title = "", showgrid = F, zeroline = F, showticklabels = F
                    ),
                    yaxis = list(
                        title = "", showgrid = F, zeroline = F, showticklabels = F
                    ),
                    zaxis = list(
                        title = "", showgrid = F, zeroline = F, showticklabels = F
                    )
                ),
                camera = list(
                    eye = list(x = 1.25, y = -1.25, z = 1.25)
                )
            ) %>%
            colorbar(len = 1, title = "") %>%
            animation_opts(frame = 5) %>%
            animation_slider(currentvalue = list(prefix = "t = "))
    }
    fig
})

## FunctionObject contour overload

#' Create a contour plot of a FunctionObject
#'
#' @param x A \code{FunctionObject} generated by \code{Function}
#' @param ... Arguments representing graphical options to be passed to \link[plotly]{plot_ly}.
#' @return A \link[plotly] object
#' @export
setMethod("contour", signature = c(x = "FunctionObject"), function(x, ...) {
    times <- x$FunctionSpace$mesh$times
    is_parabolic <- FALSE
    if (length(times) != 0) is_parabolic <- TRUE

    if (!is_parabolic) {
        plot_data <- data.frame(
            X = x$FunctionSpace$mesh$nodes()[, 1],
            Y = x$FunctionSpace$mesh$nodes()[, 2],
            coeff = x$coeff[1:nrow(x$FunctionSpace$mesh$nodes())]
        )
        I <- x$FunctionSpace$mesh$elements()[, 1]
        J <- x$FunctionSpace$mesh$elements()[, 2]
        K <- x$FunctionSpace$mesh$elements()[, 3]
        fig <- plot_ly(plot_data,
            type = "contour", x = ~X, y = ~Y, z = ~coeff,
            i = I, j = J, k = K,
            intensity = ~coeff, color = ~coeff,
            contours = list(showlabels = TRUE),
            colorbar = list(title = ""), ...
        ) %>%
            layout(
                xaxis = list(title = "", showgrid = F, zeroline = F, ticks = "", showticklabels = F),
                yaxis = list(title = "", showgrid = F, zeroline = F, ticks = "", showticklabels = F)
            )
    } else {
        plot_data <- data.frame(
            X = rep(x$FunctionSpace$mesh$nodes()[, 1], times = length(times)),
            Y = rep(x$FunctionSpace$mesh$nodes()[, 2], times = length(times)),
            coeff = as.vector(x$coeff[1:nrow(x$FunctionSpace$mesh$nodes()), ]),
            times = rep(times, each = nrow(x$FunctionSpace$mesh$nodes()))
        )
        limits <- c(min(x$coeff), max(x$coeff))
        I <- x$FunctionSpace$mesh$elements()[, 1]
        J <- x$FunctionSpace$mesh$elements()[, 2]
        K <- x$FunctionSpace$mesh$elements()[, 3]
        fig <- plot_ly(plot_data,
            type = "contour", x = ~X, y = ~Y, z = ~coeff, frame = ~times,
            i = I, j = J, k = K, zmin = limits[1], zmax = limits[2],
            intensity = ~coeff, color = ~coeff,
            contours = list(showlabels = TRUE),
            colorbar = list(title = ""), ...
        ) %>%
            layout(
                xaxis = list(title = "", showgrid = F, zeroline = F, ticks = "", showticklabels = F),
                yaxis = list(title = "", showgrid = F, zeroline = F, ticks = "", showticklabels = F)
            ) %>%
            animation_opts(frame = 5) %>%
            animation_slider(currentvalue = list(prefix = "t = "))
    }
    fig
})

# gradient of Function
.FunctionGradCtr <- setRefClass(
    Class = "FunctionGradObject",
    fields = c(
        f = "FunctionObject", ## Function of which the gradient is taken
        K = "ANY" ## set by product operator
    )
)

## take gradient of Function
setGeneric("grad", function(f) standardGeneric("grad"))
setMethod("grad", signature(f = "FunctionObject"), function(f) {
    .FunctionGradCtr(f = f)
})

setMethod("*",
    signature = c(e1 = "matrix", e2 = "FunctionGradObject"),
    function(e1, e2) {
        .FunctionGradCtr(f = e2$f, K = e1)
    }
)
